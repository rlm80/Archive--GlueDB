<?php defined('SYSPATH') OR die('No direct access allowed.');

/**
 * Base fragment class.
 *
 * A fragment is a data structure that describes a piece of SQL query and generates
 * the corresponding SQL string.
 *
 * More precisely, a fragment is any object able to generate an SQL string by combining its own
 * internal data with the SQL strings generated by other fragments. Such dependencies between
 * fragments constitute an acyclic directed graph. Fragments that depend on a specific fragment
 * in such a way are called the users of that fragment.
 *
 * Fragments cache their SQL representations. When their internal data is modified, the cache is
 * invalidated. This cache invalidation process is cascaded recursively from the fragment to its
 * users and the users of its users and so on.
 *
 * @package    GlueDB
 * @author     RÃ©gis Lemaigre
 * @license    MIT
 */

abstract class GlueDB_Fragment {
	/**
	 * @var array List of fragments that make direct use of this fragment to create their own SQL representation.
	 */
	protected $users;

	/**
	 * @var array Cached compiled SQL strings. One entry for each database.
	 */
	protected $sql = array();

	/**
	 * Returns compiled SQL string according to given database SQL dialect.
	 *
	 * @param GlueDB_Database $db
	 *
	 * @return string
	 */
	public function sql(GlueDB_Database $db = null) {
		// No database given ? Means default database :
		if ( ! isset($db))
			$db = gluedb::db(GlueDB_Database::DEFAULTDB);

		// Get name of given database instance :
		$dbname = $db->name();

		// Retrieve SQL from cache, or create it and add it to cache if it isn't there yet :
		if ( ! isset($this->sql[$dbname]))
			$this->sql[$dbname] = $this->compile($db);

		// Return SQL :
		return $this->sql[$dbname];
	}

	/**
	 * Returns freshly compiled (i.e. not retrieved from cache) SQL string, according
	 * to given database SQL dialect.
	 *
	 * @param GlueDB_Database $db
	 *
	 * @return string
	 */
	protected function compile(GlueDB_Database $db) {
		// Forwards call to database :
		return $db->compile($this);
	}

	/**
	 * Adds a fragment to the list of fragments that make direct use of this
	 * fragment to create their own SQL representation (a bit more complicated than
	 * it seems because a user may be added more than once and we have to keep
	 * track of that to remove it properly).
	 *
	 * @param GlueDB_Fragment $user
	 */
	protected function register_user(GlueDB_Fragment $user) {
		$hash = spl_object_hash($user);
		if ( ! isset($this->users[$hash]))
			$this->users[$hash] = array('object' => $user, 'count' => 1);
		else
			$this->users[$hash]['count'] ++;
	}

	/**
	 * Removes a fragment from the list of fragments that make direct use of this
	 * fragment to create their own SQL representation (a bit more complicated than
	 * it seems because a user may be removed more than once).
	 *
	 * @param GlueDB_Fragment $user
	 */
	protected function unregister_user(GlueDB_Fragment $user) {
		$hash = spl_object_hash($user);
		$this->users[$hash]['count'] --;
		if ($this->users[$hash]['count'] === 0)
			unset($this->users[$hash]);
	}

	/**
	 * Clears the SQL cache and forwards call to users. Must be called each time
	 * a change has been made to this fragment that may change its SQL.
	 */
	protected function invalidate() {
		// No need to do anything if fragment is already invalidated :
		if (count($this->sql) !== 0) {
			// Reset SQL cache :
			$this->sql = array();

			// Cascade call to parent, because if a child is invalid, the parent is necessarily invalid too :
			foreach($this->users as $user)
				$user['object']->invalidate();
		}
	}

	public function root() {
		$parent = $this->parent();
		if ( ! isset($parent))
			return $this;
		else
			return $parent->root();
	}

	public function _parent() {
		if (count($this->users) !== 0) {
			$last = end($this->users);
			return $last['object'];
		}
		else
			return null;
	}

	/**
	 * Forwards unknown calls to parent fragment. This means unknown calls bubble up the fragments tree
	 * until they reach a fragment on which they can be applied.
	 *
	 * @param string $name
	 * @param string $args
	 *
	 * @return mixed
	 */
	public function __call($name, $args) {
		if ($name === 'parent')
			return call_user_func(array($this, '_parent'));
		else {
			$parent = $this->parent();
			if (isset($parent))
				return call_user_func_array(array($parent, $name), $args);
			else
				throw new Kohana_Exception("Unknown function '" . $name . "' called on an instance of class '" . get_class($this) . "'");
		}
	}
}














